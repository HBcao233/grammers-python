from .. import types
from ..sessions import PeerId, PeerAuth
from ..tl import TLObject
from typing import Self, final
from datetime import datetime

class LoginToken:
    def __new__(cls, phone: str, phone_code_hash: str) -> Self: ...
    @property
    def phone(self) -> str: ...
    @property
    def phone_code_hash(self) -> str: ...
    def __repr__(self) -> str: ...

class SignInError(Exception):
    """Login-related errors."""

    ...

class PaymentRequiredError(SignInError):
    """
    Indicating that due to the high cost of SMS verification codes for the user's country/provider, the user must purchase a Telegram Premium subscription in order to proceed with the login/signup.
    """

    ...

class SignUpRequiredError(SignInError):
    """
    Sign-up with an official client is required. (Third-party applications cannot be used to register new accounts.)
    """

    ...

class PasswordRequiredError(SignInError):
    """
    The account has 2FA enabled, and the password is required.
    """

    ...

class InvalidCodeError(SignInError):
    """
    The code used to complete login was not valid.
    """

    ...

class InvalidPasswordError(SignInError):
    """
    The 2FA password used to complete login was not valid.
    """

    ...

class Platform:
    """
    Platform Identifier referenced only by [`RestrictionReason`].
    """
    @final
    class All(Platform):
        def __new__(cls) -> Self: ...

    @final
    class Android(Platform):
        def __new__(cls) -> Self: ...

    @final
    class Ios(Platform):
        def __new__(cls) -> Self: ...

    @final
    class WindowsPhone(Platform):
        def __new__(cls) -> Self: ...

    @final
    class Other(Platform):
        def __new__(cls, other: str) -> Self: ...

    def __repr__(self) -> str: ...

@final
class RestrictionReason:
    """
    Reason why a user is globally restricted.
    """
    def __new__(cls, reason: types.RestrictionReason): ...
    @property
    def platforms(self) -> list[Platform]: ...
    @property
    def reason(self) -> str: ...
    @property
    def text(self) -> str: ...
    def __repr__(self) -> str: ...

class User(TLObject):
    """
    A user.

    Users include your contacts, members of a group, bot accounts created by [@BotFather], or
    anyone with a Telegram account.

    A "normal" (non-bot) user may also behave like a "bot" without actually being one, for
    example, when controlled with a program as opposed to being controlled by a human through
    a Telegram application. These are commonly known as "userbots", and some people use them
    to enhance their Telegram experience (for example, creating "commands" so that the program
    automatically reacts to them, like translating messages).

    [@BotFather]: https://t.me/BotFather
    """
    def __new__(cls, user: types.User | types.UserEmpty): ...
    @property
    def id(self) -> PeerId: ...
    @property
    def access_hash(self) -> PeerAuth | None: ...
    @property
    def bot(self) -> bool: ...
    @property
    def is_self(self) -> bool: ...
    @property
    def restriction_reason(self) -> RestrictionReason: ...
    @property
    def contact(self) -> bool: ...
    @property
    def mutual_contact(self) -> bool: ...
    @property
    def deleted(self) -> bool: ...
    @property
    def bot_chat_history(self) -> bool: ...
    @property
    def bot_nochats(self) -> bool: ...
    @property
    def verified(self) -> bool: ...
    @property
    def restricted(self) -> bool: ...
    @property
    def min(self) -> bool: ...
    @property
    def bot_inline_geo(self) -> bool: ...
    @property
    def support(self) -> bool: ...
    @property
    def scam(self) -> bool: ...
    @property
    def apply_min_photo(self) -> bool: ...
    @property
    def fake(self) -> bool: ...
    @property
    def bot_attach_menu(self) -> bool: ...
    @property
    def premium(self) -> bool: ...
    @property
    def attach_menu_enabled(self) -> bool: ...
    @property
    def bot_can_edit(self) -> bool: ...
    @property
    def close_friend(self) -> bool: ...
    @property
    def stories_hidden(self) -> bool: ...
    @property
    def stories_unavailable(self) -> bool: ...
    @property
    def contact_require_premium(self) -> bool: ...
    @property
    def bot_business(self) -> bool: ...
    @property
    def bot_has_main_app(self) -> bool: ...
    @property
    def bot_forum_view(self) -> bool: ...
    @property
    def first_name(self) -> str | None: ...
    @property
    def last_name(self) -> str | None: ...
    @property
    def username(self) -> str | None: ...
    @property
    def phone(self) -> str | None: ...
    @property
    def photo(self) -> types.UserProfilePhoto | None: ...
    @property
    def status(self) -> types.UserStatus | None: ...
    @property
    def bot_info_version(self) -> int | None: ...
    @property
    def bot_inline_placeholder(self) -> str | None: ...
    @property
    def lang_code(self) -> str | None: ...
    @property
    def emoji_status(self) -> types.EmojiStatus | None: ...
    @property
    def usernames(self) -> list[types.Username]: ...
    @property
    def stories_max_id(self) -> types.RecentStory | None: ...
    @property
    def color(self) -> types.PeerColor | None: ...
    @property
    def profile_color(self) -> types.PeerColor | None: ...
    @property
    def bot_active_users(self):
        (int | None,)
    @property
    def bot_verification_icon(self):
        (int | None,)
    @property
    def send_paid_messages_stars(self):
        (int | None,)

class Group(TLObject):
    """
    A group chat.

    Telegram's API internally distinguishes between "small group chats" and "megagroups", also
    known as "supergroups" in the UI of Telegram applications.

    Small group chats are the default, and offer less features than megagroups, but you can
    join more of them. Certain actions in official clients, like setting a chat's username,
    silently upgrade the chat to a megagroup.
    """
    def __new__(
        cls,
        group: types.Chat
        | types.ChatEmpty
        | types.ChatForbidden
        | types.Channel
        | types.ChannelForbidden,
    ) -> Self: ...
    @property
    def id(self) -> PeerId:
        """
        Return the unique identifier for this group.

        Note that if this group is migrated to a megagroup, both this group and the new one will
        exist as separate chats, with different identifiers.
        """
        ...
    @property
    def title(self) -> str | None:
        """
        Return the title of this group.

        The title may be the empty string if the group is not accessible.
        """
        ...
    @property
    def date(self) -> datetime | None:
        """
        Date when the user joined the supergroup/channel,
        or if the user isn't a member, its creation date.
        """
        ...
    @property
    def date_timestamp(self) -> int | None:
        """
        `date` origin data.
        """
        ...
    @property
    def access_hash(self) -> PeerAuth | None: ...
    @property
    def broadcast(self) -> bool | None:
        """
        Whether this is a channel, always false.
        """
        ...
    @property
    def megagroup(self) -> bool | None:
        """
        Whether this is a supergroup, always true.
        """
        ...
    @property
    def until_date(self) -> datetime | None:
        """
        The ban is valid until the specified date.
        """
        ...
    @property
    def until_date_timestamp(self) -> int | None:
        """
        `until_date` origin data.
        """
        ...
    @property
    def creator(self) -> bool | None:
        """
        Whether the current user is the creator of this channel.
        """
        ...
    @property
    def left(self) -> bool | None:
        """
        Whether the current user has left or is not a member of this channel.
        """
        ...
    @property
    def deactivated(self) -> bool | None: ...
    @property
    def call_active(self) -> bool | None: ...
    @property
    def call_not_empty(self) -> bool | None: ...
    @property
    def noforwards(self) -> bool | None:
        """
        Whether this channel or group is protected, thus does not allow forwarding messages from it.
        """
        ...
    @property
    def photo(self) -> types.ChatPhoto | None: ...
    @property
    def participants_count(self) -> int | None: ...
    @property
    def version(self) -> int | None: ...
    @property
    def migrated_to(self) -> types.InputChannel | None: ...
    @property
    def admin_rights(self) -> types.ChatAdminRights | None: ...
    @property
    def default_banned_rights(self) -> types.ChatBannedRights | None: ...
    @property
    def verified(self) -> bool | None:
        """
        Whether this channel is verified by telegram.
        """
        ...
    @property
    def restricted(self) -> bool | None: ...
    @property
    def signatures(self) -> bool | None: ...
    @property
    def min(self) -> bool | None: ...
    @property
    def scam(self) -> bool | None: ...
    @property
    def has_link(self) -> bool | None: ...
    @property
    def has_geo(self) -> bool | None: ...
    @property
    def slowmode_enabled(self) -> bool | None: ...
    @property
    def fake(self) -> bool | None: ...
    @property
    def gigagroup(self) -> bool | None:
        """
        Whether this supergroup is a gigagroup.
        """
        ...
    @property
    def join_to_send(self) -> bool | None:
        """
        Whether a user needs to join the supergroup before they can send messages:
        can be false only for discussion groups.
        toggle using `channels.toggleJoinToSend`
        """
        ...
    @property
    def join_request(self) -> bool | None: ...
    @property
    def forum(self) -> bool | None: ...
    @property
    def stories_hidden(self) -> bool | None: ...
    @property
    def stories_hidden_min(self) -> bool | None: ...
    @property
    def stories_unavailable(self) -> bool | None: ...
    @property
    def signature_profiles(self) -> bool | None: ...
    @property
    def autotranslation(self) -> bool | None: ...
    @property
    def broadcast_messages_allowed(self) -> bool | None: ...
    @property
    def monoforum(self) -> bool | None: ...
    @property
    def forum_tabs(self) -> bool | None: ...
    @property
    def username(self) -> str | None: ...
    @property
    def restriction_reason(self) -> list[RestrictionReason] | None: ...
    @property
    def banned_rights(self) -> types.ChatBannedRights | None: ...
    @property
    def usernames(self) -> list[types.Username]: ...
    @property
    def stories_max_id(self) -> types.RecentStory | None: ...
    @property
    def color(self) -> types.PeerColor | None: ...
    @property
    def profile_color(self) -> types.PeerColor | None: ...
    @property
    def emoji_status(self) -> types.EmojiStatus | None: ...
    @property
    def level(self) -> int | None: ...
    @property
    def subscription_until_date(self) -> datetime | None: ...
    @property
    def subscription_until_date_timestamp(self) -> int | None: ...
    @property
    def bot_verification_icon(self) -> int | None: ...
    @property
    def send_paid_messages_stars(self) -> int | None: ...
    @property
    def linked_monoforum_id(self) -> int | None: ...

class Channel(TLObject):
    """
    A broadcast channel.

    In a broadcast channel, only administrators can broadcast messages to all the subscribers.
    The rest of users can only join and see messages.

    Broadcast channels and megagroups both are treated as "channels" by Telegram's API, but
    this variant will always represent a broadcast channel. The only difference between a
    broadcast channel and a megagroup are the permissions (default, and available).
    """
    def __new__(cls, channel: types.Channel | types.ChannelForbidden) -> Self: ...
    @property
    def id(self) -> PeerId: ...
    @property
    def title(self) -> str:
        """
        Return the title of this channel.
        """
        ...

    @property
    def access_hash(self) -> PeerAuth | None: ...
    @property
    def username(self) -> str | None:
        """
        Return the deflic @username of this channel, if any.

        The returned username does not contain the "@" prefix.

        Outside of the application, people may link to this user with one of Telegram's URLs, such
        as https://t.me/username.
        """
        ...

    @property
    def usernames(self) -> list[types.Username]:
        """
        Return collectible usernames of this channel, if any.

        The returned usernames do not contain the "@" prefix.

        Outside of the application, people may link to this user with one of its username, such
        as https://t.me/username.
        """
        ...

    @property
    def photo(self) -> types.ChatPhoto | None:
        """
        Return the photo of this channel, if any.
        """
        ...

    @property
    def date(self) -> datetime | None: ...
    @property
    def date_timestamp(self) -> int | None: ...
    @property
    def until_date(self) -> datetime | None: ...
    @property
    def until_date_timestamp(self) -> int | None: ...
    @property
    def broadcast(self) -> bool: ...
    @property
    def megagroup(self) -> bool: ...
    @property
    def creator(self) -> bool | None: ...
    @property
    def left(self) -> bool | None: ...
    @property
    def verified(self) -> bool | None: ...
    @property
    def restricted(self) -> bool | None: ...
    @property
    def signatures(self) -> bool | None: ...
    @property
    def min(self) -> bool | None: ...
    @property
    def scam(self) -> bool | None: ...
    @property
    def has_link(self) -> bool | None: ...
    @property
    def has_geo(self) -> bool | None: ...
    @property
    def slowmode_enabled(self) -> bool | None: ...
    @property
    def call_active(self) -> bool | None: ...
    @property
    def call_not_empty(self) -> bool | None: ...
    @property
    def fake(self) -> bool | None: ...
    @property
    def gigagroup(self) -> bool | None: ...
    @property
    def noforwards(self) -> bool | None: ...
    @property
    def join_to_send(self) -> bool | None: ...
    @property
    def join_request(self) -> bool | None: ...
    @property
    def forum(self) -> bool | None: ...
    @property
    def stories_hidden(self) -> bool | None: ...
    @property
    def stories_hidden_min(self) -> bool | None: ...
    @property
    def stories_unavailable(self) -> bool | None: ...
    @property
    def signature_profiles(self) -> bool | None: ...
    @property
    def autotranslation(self) -> bool | None: ...
    @property
    def broadcast_messages_allowed(self) -> bool | None: ...
    @property
    def monoforum(self) -> bool | None: ...
    @property
    def forum_tabs(self) -> bool | None: ...
    @property
    def restriction_reason(self) -> list[RestrictionReason]: ...
    @property
    def admin_rights(self) -> types.ChatAdminRights | None: ...
    @property
    def banned_rights(self) -> types.ChatBannedRights | None: ...
    @property
    def default_banned_rights(self) -> types.ChatBannedRights | None: ...
    @property
    def participants_count(self) -> int | None: ...
    @property
    def stories_max_id(self) -> types.RecentStory | None: ...
    @property
    def color(self) -> types.PeerColor | None: ...
    @property
    def profile_color(self) -> types.PeerColor | None: ...
    @property
    def emoji_status(self) -> types.EmojiStatus | None: ...
    @property
    def level(self) -> int | None: ...
    @property
    def subscription_until_date(self) -> datetime | None: ...
    @property
    def subscription_until_date_timestamp(self) -> int | None: ...
    @property
    def bot_verification_icon(self) -> int | None: ...
    @property
    def send_paid_messages_stars(self) -> int | None: ...
    @property
    def linked_monoforum_id(self) -> int | None: ...
